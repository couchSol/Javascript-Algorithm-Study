# 빅오 표기법
## 빅오 표기법이란
* 입력 내용 N에 따라 실행 시간이 어떻게 변하는지 설명해주는 표기법이다
* 실행시간의 최대치를 말한다
* **전반적인 추세**를 측정하고 디테일은 버린다

## 시간 복잡성 측정
### 측정하는 것 : 컴퓨터가 처리해야 하는 연산의 개수
연산이란 사칙연산(+ , - , * , /), 할당(=), 비교(< , >)등을 말한다

### 측정 규칙
    1. 산수와 상수는 버린다   
        연산이 n^2 + 5n + 2회라면 곱해진거나 더해진 것들은 버리고 O(n^2)로 표기한다
    2. 변수 할당에 걸리는 시간은 상수이다   
    3. index를 이용해 배열 안의 element에 접근하거나, key를 이용해 객체 내의 데이터에 접근하는 데 걸리는 시간은 상수이다
    4. 반복문의 복잡도는 '반복문의 길이 * 반복문 안의 연산'이다

### 5가지 경우

#### 상수 시간 O(1)
n의 변화와 관계없이 항상 같은 수의 연산을 실행한다.
```javascript
// 언제나 3회의 연산을 실행
n * (n + 1) / 2
```

#### O(log n)


#### O(n)
n이 커질 때 연산이 항상 같은 비율로 증가함
```javascript
// 0에서 n까지 더하는 반복문의 연산 횟수는 1n
```
#### O(n * log n)

#### O(n^2)
```javascript
// 0에서 n까지 돌면서 0에서 n까지 세는 중첩된 반복문은 n * n 번의 연산을 실행한다
```

## 공간 복잡성 측정
### 측정하는 것 : 알고리즘 자체가 차지하는 메모리 용량
알고리즘 코드 자체가 가진 숫자, 문자, 배열 등의 크기를 측정하고, 입력되는 값 n의 크기는 측정하지 않는다.
영어로는 auxiliary space complexity라고 한다

### 측정 규칙
    1. boolean, num, undefined, null 은 불변 공간이다 => 상수
        - 숫자가 1이든 1000이든, 불이 true이든 false이든 같은 공간을 차지한다
    2. 문자열의 길이가 n일 때 O(n) 공간을 차지한다
    3. 배열의 길이 or 객체의 key 개수가 n일 때 O(n) 공간을 차지한다 

--------
# 문제해결 접근법
## 1단계 : 문제 이해하기
다음의 질문들을 던져보자
    * 질문을 내 말로 풀어 설명할 수 있는가?
    * 문제의 input과 output은 무엇인가?
        - 숫자라면 얼마나 큰가? 부동소수점인가?
        - input 개수가 부족하면 어떻게 처리할 것인가?
    * input만으로 output이 반환될 수 있을까? 문제 해결을 위한 충분한 정보를 가지고 있는가?
    * 데이터의 중요한 부분에 어떻게 라벨을 붙일 수 있을까?

## 2단계 : 구체적 예시 찾기
예시를 떠올리면 문제를 이해하는 데 도움이 될 뿐만 아니라,
해법이 제대로 작동하는지 온전성 검사(sanity check)의 역할을 한다.
유저스토리(who가 purpose를 위해서 what을 원한다)나 유닛테스트로 세부적 틀을 잡는 것과 비슷한 개념.
    * 가장 쉬운 사용례부터 시작한다
        - 단순한 input과 이에 따른 단순한 output을 작성해 본다
    * 더 복잡한 예시로 넘어가며 다양한 경우를 어떻게 처리할 지 생각한다
    * 빈 입력값의 경우를 탐색한다
    * 유효하지 않은 입력값의 경우를 탐색한다

## 3단계 : 작은 단계들로 쪼개기
    * 주석이나 의사코드를 작성하며 전반적인 로직과 단계를 체크한다
    * 리턴할 객체 만들기, 변환과 반복문 중 어느 것을 먼저 할지, if문 안의 분기 조건과 리턴값 등 세부적인 사항에 대해 결정해 나간다
    * 개이득 : 코딩테스트 시 정답을 도출하지 못했더라도 과정을 짜는 능력까지는 입증할 수 있다

## 4단계 : 해결하기 / 단순화하기
당장 해결할 방법을 모르겠다면 쉬운 부분을 집어내 먼저 해결한다.
    * 핵심적인 어려움이 무엇인지 찾는다
    * 잠깐 그 어려움을 무시한다
    * 쉬운 부분의 해결방법을 작성한다
    * 해결한 쉬운 부분을 어려운 부분과 다시 통합한다
욕심을 내서 어려운 로직을 한 뭉텅이로 몰아넣거나 차례대로 술술 적어내려고 하다가는 오히려 못 풀고 쩔쩔메게 된다.
문제를 단순화하는 과정에서 근본적 해결책의 인사이트를 얻는 경우가 많다.

## 5단계 :  뒤돌아보고 리팩토링하기
한 줄씩 읽어보며 얼마나 효율적이고 읽기 쉬운지 체크하기
작성한 코드에 만족하고 그만두고 싶은 유혹에 빠지기 쉽지만, 리팩토링은 정말 중요하다!
    * 결과를 다른 방식으로 도출할 수 있나?
    * 한눈에 보고 이해할 수 있나? 얼마나 직관적인가?
    * 이 결과나 방식을 다른 문제에도 적용할 수 있는가?
    * 해결책의 성능을 향상시킬 수 있는가? (빅오 관점)
    * 스타일 가이드나 규칙에 맞는가?
    * 다른 사람들은 이 문제에 대해 어떻게 생각했는가? (다른 언어로 쓰인 해결책이라도 종종 들여다보고 공부하기!)


--------
# 문제해결 패턴(청사진)
## Frequency Counter: 빈도수 세기

다중포인터와 윈도우의 차이........??
윈도우 장점을 생각해 보면
1. 시간복잡도 측면에서 효율적
2. 이런 경우에서 떠올릴 수 있는 사고방식이 +1 되었다
3. '연속된' 무언가를 확인할 때 좋다
4. window의 length가 가변적이다


--------
## 중요하지 않지만 괜찮은 팁들
* snippet으로 코드 적기
    - 개발자도구 - resource - snippet에 코드를 적고 저장할 수 있다

* 메소드로 코드 실행 속도를 측정하는 방법
    - 측정 환경에 따라 결과는 다르게 나온다
    ```
    let time1 = performance.now();
    testFunction();
    let time2 = performance.now();
    console.log(`time elapsed: ${(time2 - time1) / 1000} seconds.`)
    ```

* log가 헷갈릴 때면 다시 section2의 11번 영상으로 돌아가 보기