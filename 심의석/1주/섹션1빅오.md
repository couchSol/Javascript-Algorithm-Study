### 좋은 코드를 짜기 위해서 무엇을 고려해야 할까?

---

- 실행시간이 얼마나 빠른지?
- 저장공간이 얼마나 필요한지?
- 코드의 가독성이 얼마나 좋은지? <br />

##### 좋은 코드를 짜기 위해서 위의 것들을 고려해볼 것이다. 이 중 메인으로 고려할 요소는 첫번째와 두번쨰 요소이다. 어떤 알고리즘은 실행시간이 빠르나 저장공간이 많이 필요할 수도 있고 또 다른 알고리즘은 저장공간은 적게 필요하지만 실행시간이 매우 느려질 수 있다. 따라서 우리는 효율성을 비교하여 적절히 알고리즘을 짜야한다. 이를 위해 <strong>'빅오표기법'</strong>을 보통 많이 사용한다.

<br/>

# 빅오표기법

- 알고리즘의 효율성을 표기해주는 표기법
- 데이터 개수(N)에 따른 전체적인 추세를 측정
- 시간 복잡도(시간효율성)와 공간 복잡도(공간효율성)를 나타내는데 사용

## 빅오표기법 특징

> 1. 상수항은 무시한다.<br/>
>    O(5N+2) -> O(N)<br/>
>
> - 데이터개수 즉 N이 충분히 크다고 가정한다면 데이터 입력값 N의 크기에 따라 영향을 받으므로 사소한 영향을 주는 상수항은 무시하고 표기 한다.
>
> 2.  영향력 없는 항은 무시한다.<br/>
>     O(N^2+5N+2) -> O(N^2) <br/>
>
> - 데이터 입력값(N)에 따라 영향을 받기 떄문에 N^2의 영향력에 비해 5N이나 2의 영향력은 미비하다 할 수 있다. 따라서 영향력이 없는 항들은 무시하고 표기 한다.

## 시간복잡성

---

> - 데이터 입력값(N)에 따라 처리해야 하는 연산의 횟수
> - 연산에는 사칙연산, 비교, 할등 등이 있다.

  <img src="https://velog.velcdn.com/images%2Fgillog%2Fpost%2F1506c01a-ba40-4255-b549-03c8bb038049%2F1.png">

### O(1)

---

- N의 값에 상관없이 일정한 연산을 실행하므로 거의 일정한 실행시간을 갖는다. 따라서 N값이 매우 크다고 가정하면 위의 그래프에서 일직선의 형태를 갖는다.
- 상수값이 상상이상으로 클 경우 일정한 시간의 의미가 없다. 따라서 신중하게 고려해서 써야한다.

```js
function addUpToSecond(n) {
  return (n * (n + 1)) / 2;
}
// 0부터 n까지 더하는 알고리즘이다.
// n값이 아무리 커져도 항상 연산 3회 실행(덧셈, 곲셈, 나눗셈)
```

### O(N)

---

- N값에 비례하여 연산을 실행하므로 알고리즘을 수행하는데 걸리는 시간은 입력값에 비례한다.
- 선형 시간 알고리즘이라 한다.

```js
function addUpToFirst(n) {
  var total = 0;
  for (let i = 0; i <= n; i++) {
    total += i;
  }
  return total;
}
// 0부터 n까지 더하는 알고리즘이다. -> 1n
// n이 커질때수록 연산 횟수는 비례하여 증가한다.
```

### O(N^2)

---

- 이중 반복문이 이에 해당된다.

```js
function printAllPairs(n) {
  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      console.log(i, j);
    }
  }
}
// 0부터 n까지 탐색 할 떄, 각각을 또 0부터 n까지 탐색 -> n*n
```

### O(logN)

---

- 데이터 입력값(N)에 따라 실행시간이 로그적으로 변하는 알고리즘이다.
- 로그는 매우 큰 입력값에도 크게 영향을 받지 않는다.
- 이진 탐색 알고리즘 등이 이에 해당된다.

### O(NlogN)

---

- 병합, 정렬등의 효율이 좋은 알고리즘등이 이에 해당된다.

### O(2^N)

---

- 피보나치 수를 재귀로 계산하는 알고리즘이 이에 해당된다.

### O(n!)

---

- 가장 느린 알고리즘으로 입력값이 조금만 커져도 계산이 어렵다.

## 공간복잡성

---

> - 알고리즘을 사용할 때 메모리 사용량을 나타낸다.
> - 만약 크기가 N인 배열을 만들면 공간 복잡도가 O(N)이 되고, N²인 배열을 만들면 O(N²)이 된다.
> - 재귀 함수 호출의 경우 스택 공간을 고려 해야 한다.

```js
// N일때 스택에 쌓이는 메모리는 sum(1) + sum(2) + sum(3) + ... + sum(N)이므로 공간복잡도가 O(N)이다.
function sum(N) {
  sum = 0;
  if (N < 1) return 0;
  return N + sum(N - 1);
}
```
